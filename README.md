#### 안드로이드프로그래밍 1반
#### 2017261002 박수은

# markdown 문법
README 파일이나 온라인 문서, 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰이는 문법
- 다른 포켓에 글을 옮겨도 원본의 손실이 최소화 된다는 장점이 있음  

1. 제목
# 대주제
## 중주제
### 소주제

2. 목록
* 내용 1
* 내용 2
  * 하위내용 1
  * 하위내용 2

3. 텍스트 형태

**Bold**

__Bold__

*Italic*

_Italic_

~~Cancel~~

4. 구분선
---

5. 링크

[name](주소)

6. 블록
>	내용

# git 명령어
> git --version

현재 git의 버전을 확인

> git init

현재 디렉토리에 git 저장소를 생성

> git add *파일명*

(*파일명* ex/ hello.txt)

untracked files의 파일들을 git가 추적하도록 하거나

파일은 수정했지만 아직 스테이징 영역에 올라가지 않은 파일들을 스테이징 영역에 올림
* -i : 대화형모드가 시작되며, 파일의 일부분만 선택해서 스테이징 가능
* -p : 대화형모드 없이 바로 패치모드 사용

> git commit -m "*커밋메시지*"

스테이징 영역에 올라가 있는 파일들을 커밋

* -m : 커밋메시지를 주는 옵션으로, 여러 줄의 커밋메시지를 쓸 경우 -m을 여러개 사용
* -a : 스테이징에 올리는 작업과 커밋을 동시에 실행

> git commit -C HEAD -a --amend

지정한 커밋의 로그메시지를 다시 사용하여 기존커밋을 수정
* -c : 기존메시지를 수정할 수 있는 편집기를 실행

> git status

커밋되지 않은 변경사항 조회

> git diff

스테이징영역과 현재 작업트리의 차이점을 보여줌
* --cached : 스테이징영역과 저장소의 차이점을 볼 수 있음
* git diff HEAD : 저장소, 스테이징영역, 작업트리의 차이점을 모두 볼 수 있음
* --stat : 변경사항에 대한 통계를 볼 수 있음

> git mv *파일명* *새파일명*

기존에 존재하는 파일을 새파일로 이동

> git branch

현재 존재하는 브랜치를 조회
* -r : 원격저장소의 브랜치를 확인

> git branch *브랜치명B* *브랜치명A*

브랜치명A에서 새로운 브랜치 브랜치명B 만듦

> git branch *브랜치명*

브랜치명의 새로운 브랜치를 만듦

> git branch -d *브랜치명*

브랜치를 삭제

> git branch -m *존재하는브랜치명* *새로운브랜치명*

존재하는 브랜치를 새로운브랜치로 변경
* -M : 이미 있는 브랜치의 경우에도 덮어씀

> git tag *태그명* *브랜치명*

브랜치명의 현재시점에 태그명으로 된 태그를 붙임

> git checkout *브랜치명/태그명*

해당 브랜치나 태그로 작업트리를 변경

> git checkout -b *브랜치명B* *브랜치명A*

브랜치명A에서 브랜치명B라는 새로운 브랜치를 만들면서 체크아웃

> git rebase *브랜치명*

브랜치명의 변경사항을 현재 브랜치에 적용

> git merge *브랜치명*

브랜치명의 브랜치를 현재 브랜치로 합침
* --squash : 브랜치명의 모든 커밋을 하나의 커밋으로 만듦

> git cherry-pick *커밋명*

커밋명의 특정 커밋만을 선택해서 현재 브랜치에 커밋으로 만듦
* -n : 작업트리에 합치지만 커밋은 하지 않기 때문에 여러개의 커밋을 합쳐서 커밋

> git log

커밋로그 보여줌
* -1 or -2 or … : 출력할 커밋로그의 갯수를 지정
* --pretty=oneline : 한줄로 간단히 보여줌
* --pretty=format : "%h %s"와 같이 형식 지정
* -p : 변경된 내용 같이 보여줌
* --graph : 브랜치 트리 보여줌

> git log *커밋명*

해당 커밋명의 로그 보여줌
* *커밋명A*..*커밋명B* : 커밋명A 이후부터 커밋명B 까지의 로그 보여줌

> git blame -M *파일명*

반복되는 패턴을 찾아서 복사하거나 이동된 내용을 찾아줌
* -C : 파일간의 복사한 경우를 찾아줌
* -p : 내용의 복사를 찾아줌

> git revert *커밋명*

기존의 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만듦
* -n : 바로 커밋하지 않고 revert를 여러번한 다음에 커밋

> git reset *커밋명*

이전 커밋을 수정
* --soft : 이전 커밋을 스테이징하고 커밋은 하지 않음
* --hard : 저장소와 작업트리에서 커밋을 제거

> git rebase -i *커밋범위*

대화형모드로 커밋 순서를 변경하거나 합침

> git clone *저장소주소* *폴더명*

원격저장소를 복제하여 저장소를 생성

> git fetch

원격저장소의 변경사항 가져와서 원격브랜치를 갱신

> git pull

원격저장소의 변경사항을 가져와서 지역브랙치에 합치는 작업을 한꺼번에 함

> git remote add *이름* *저장소주소*

새로운 원격 저장소를 추가

> git remote

추가한 원격저장소의 목록을 확인

> git remote show *이름*

해당 원격저장소의 정보를 봄

> git remote rm *이름*

원격저장소를 제거

> git submodule

연관된 하위모듈을 확인

> git submodule add *저장소주소* *서브모듈경로*

새로운 하위모듈을 해당경로에 추가

> git submodule init *서브모듈경로*

서브모듈을 초기화

> git submodule update *서브모듈경로*

서브모듈의 변경사항을 적용

> git mergetool

설정에 merge.tool의 값에 있는 머지툴을 찾아서 실행

> git gc

저장소의 로그를 최적화-로그가 변경되지는 않고 저장하는 방식만 최적화
* --aggressive : 더 자세하게 최적화

> git rev-parse --show-toplevel

git 저장소내에서 입력하면 루트디렉토리를 알려줌
